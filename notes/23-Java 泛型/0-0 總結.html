<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

    关键术语
    actual concrete type （实际具体类型）

    bounded generic type （受限泛型类型）

    bounded wildcard(<? extends E>) （受限通配）

    formal generic type(形式泛型类型)

    generic instantiation(泛型实例化)

    lower-bound wildcard(<? super E>) （下限通配）

    raw type(原始类型)

    unbounded wildcard(<?>)（非受限通配）

    本章小结
    泛型具有参数化类型的能力。可以定时使用泛型类型的类活方法，编译器会用具体类型来替换泛型类型。

    泛型的主要优势是能够在编译时而不是在运行时检测错误。

    泛型类或者方法允许指定这个类或者方法带有的对象类型。如果试图使用带有不兼容对象的类或者方法，编译器会检测出这个错误。

    定义在类、接口或者静态方法中的泛型成为形式泛型类型，随后可以用一个实际具体类型来替换它。替换泛型类型的过程成为泛型实例化。

    不使用类型参数的泛型成为原始类型，比如ArrayList。使用原始类型是为了向后兼容Java较早的版本。

    通配泛型类型有三种形式：
        ?、？ extends T 和 ? super T, 这里的T代表一个泛型类型。
        第一种形式？称为非受限通配，它和 ? extends Object是一样的。
        第二种形式 ? extends T 称为受限通配，代表T或者T的一个子类型。
        第三种类型? super T称为下限通配，表示T或者T的一个父类型。

    使用称为泛型消除的方法来实现泛型。编译器使用泛型类型信息来编译代码，但是随后消除它。因此，泛型信息在运行时是不可用的。这个方法能够使泛型代码向后兼容使用原始类型的遗留代码。

    不能使用泛型类型参数来创建实例。

    不能使用泛型类型参数来创建数组。

    不能在静态环境中使用类的泛型类型参数。

    在异常类中不能使用泛型类型参数。

</body>
</html>